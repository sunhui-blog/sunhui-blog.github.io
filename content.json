{"pages":[],"posts":[{"title":"Docker和Jenkins构建CI/CD流水线","text":"https://www.infoq.cn/article/wht0wfmdrrbu-dtkh1xp","link":"/2021/01/29/Docker和Jenkins构建CI-CD流水线/"},{"title":"设计一套程序设计语言","text":"https://zhuanlan.zhihu.com/p/161783546","link":"/2021/09/13/设计一套程序设计语言/"},{"title":"JavaScript严格模式","text":"严格模式为了修复Javascript语法的不严谨性。 初始化未经声明的变量会导致错误。 arguments.callee/arguments.caller会导致错误。 不能为函数的caller属性赋值，否则会导致错误。 严格模式下，在外部访问不到eval()中创建的任何变量或函数，为eval赋值也会导致错误； 12345678910// 非严格模式eval(&quot;function sayHi () { alert(&apos;hi&apos;); }&quot;)sayHi() // &quot;hi&quot;eval(&quot;var msg= &apos;hello world&apos;; &quot;)alert(msg) // &quot;hello world&quot;// 严格模式&quot;use strict&quot;eval = &apos;hi&apos; // 抛出error 创建变量和函数类似 Object.defineProperty()的writable(Configurable)设置为false时，再对属性做赋值(delete属性)时，严格模式会抛出异常，非严格模式不会； 12345678910111213141516Object.defineProperty(person, &quot;name&quot;, { writable: false, value: &apos;Nicholas&apos;})console.log(person.name) // &apos;Nicholas&apos;person.name = &apos;lilei&apos;console.log(person.name) // &apos;Nicholas&apos;&quot;use strict&quot;Object.defineProperty(person, &quot;name&quot;, { writable: false, value: &apos;Nicholas&apos;})console.log(person.name) // Nicholasperson.name = &apos;lilei&apos; // 抛出errorconsole.log(person.name) 访问器属性：在严格模式下，尝试写入只指定了getter函数的属性抛出错误；(类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，在严格模式下会抛出错误??)。 1234567891011121314151617181920212223242526&quot;use strict&quot;;let book = { _year: 2020, edition: 1}Object.defineProperty(book, &quot;year&quot;, { get: function () { return this._year }})book.year = 2021 // 抛出错误&quot;use strict&quot;;let book = { _year: 2020, edition: 1}Object.defineProperty(book, &quot;year&quot;, { set: function (newValue) { this._year = newValue this.edition++ }})book.year // 非严格模式下 undefined call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 function.call(thisArg, arg1, arg2, …) thisArg:可选的。在 function 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，原始值会被包装。 123456789&quot;use strict&quot;window.color = &quot;red&quot;let o = { color: &quot;blue&quot; }function sayColor() { console.log(this.color)}sayColor.call(null); // error 非严格：redsayColor.call(undefined); // error 非严格：red","link":"/2020/01/03/JavaScript/JavaScript严格模式/"},{"title":"JavaScript原型","text":".l30{text-indent:30px;} 加深此处理解。 以下内容出自《你不知道的JavaScript》上卷、《JavaScript高级程序设计》。 “类是基于复制的，原型是基于关联的” 在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。 JavaScript中并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们[[Prototype]]关联的是同一个对象。但是在默认情况下并不会进行复制，因此这些对象之间并不会完全失去联系，它们是相互关联的。 利用函数的特殊特性：所有的函数(如函数A)都会拥有一个名为prototype的公有且不可枚举的属性，它会指向另一个对象，这个对象通常被称为A的原型。我们通过A.prototype来访问它。 12345function A() {}const a = new A(); // new 并没有直接关联，间接关联(意外的副作用)Object.getPrototypeOf(a) === A.prototype // true Object.create(…): 创建一个对象并把这个对象的[[Prototype]]关联到指定的对象。缺点:需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象。 e.g.把A.prototype关联到B.prototype的方法： 12345// ES6之前需要抛弃默认的A.prototypeA.prototype = Object.create(B.prototype)// ES6开始可以直接修改现有的B.prototypeObject.setPrototypeOf(A.prototype, B.prototype) Object.create(null)会创建一个拥有空(null)[[Prototype]]链接的对象，这个对象无法进行委托。由于这个对象没有原型链，instanceof操作符无法进行判断(始终为false)，这些特殊的空[[Prototype]]对象通常被称作”字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。 &lt;附&gt; 函数的特殊特性？ #未完待续#","link":"/2019/10/28/JavaScript/JavaScript原型/"},{"title":"JavaScript判断对象是否一致","text":"总结一下这个问题！可用于判断用户在form表单编辑页面是否变更了数据内容。减少编辑form接口请求~当然这个比对的意义随需求变化而变化。 .red{color:red;} 方法：Object.keys ＋ some()(或者every()) Array.prototype.some() some() 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。有一个为”真”，则返回真 123456const a = {age: 1, name: &apos;a&apos;}const b = {age: 1, name: &apos;b&apos;}function isObjEqual (objA, objB) { return Object.keys(objA).some(key =&gt; { return objA[key] !== objB[key] })}isObjEqual(a, b) // true:不一致 false:一致 Array.prototype.every() every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个会使 callback 返回 false 的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。有一个为”假”，则返回假 123456const a = {age: 1, name: &apos;a&apos;}const b = {age: 1, name: &apos;b&apos;}function isObjEqual (objA, objB) { return Object.keys(objA).every(key =&gt; { return objA[key] === objB[key] })}isObjEqual(a, b) // true:一致 false:不一致 &lt;附&gt; 此处也可用for…in来实现 循环中断参考：https://juejin.im/entry/5884717a1b69e6005919f0d3","link":"/2019/09/04/JavaScript/JavaScript判断对象是否一致/"},{"title":"JavaScript实现继承的几种方式","text":"继承：是面向对象（to:wiki）Object-oriented_programming软件技术当中的一个概念，与多态、封装共为面向对象的三个基本特征。 继承可以使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。 以下内容出自《JavaScript高级程序设计》，此部分看过多遍，此处总结归纳一下。 原型链 实现继承的基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。 类中构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。让原型对象等于另一个类型的实例。则原型对象将包含一个指向另一个原型的指针。同时包含一个指向另一个构造函数的指针。层层递进，就构成了实例和原型的链条。 12345678910111213141516171819202122232425function Animal() { this.home = &quot;earth&quot;}Animal.prototype.say = function () { return &quot;hello&quot;}function Cat(color) { this.color = color}// 原型对象等于另一个类型的实例Cat.prototype = new Animal()// 添加新方法Cat.prototype.eat = function () { return &quot;fish&quot;}var whiteCat = new Cat()alert(whiteCat.home) // &quot;earth&quot;alert(whiteCat.say()) // &quot;hello&quot;alert(whiteCat.eat()) // &quot;fish&quot; &lt;注&gt; 给原型添加方法的代码一定要放在替换原型的语句之后； 不能使用对象字面量创建原型方法； 原型中包含引用类型值(如数组)，多个子类改变父类属性及方法会相互干扰； 没办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数； 则很少单独使用 借用构造函数 实现继承的基本思想：在子类型构造函数的内部调用超类型构造函数。借助apply()和call()方法。 123456789101112131415161718function Animal() { this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]}function Cat() { Animal.call(this)}var calico = new Cat()calico.colors.push(&quot;white&quot;)var blackCat = new Cat()blackCat.colors = &quot;black&quot;console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]console.log(blackCat.colors) // &quot;black&quot; &lt;注&gt; 采用此方法，方法都在构造函数中定义，函数复用无从谈起。在父原型中定义的方法，对子类型而言不可见，则所有类型都只能使用构造函数模式。则很少单独使用 组合继承 实现继承的基本思想：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。既通过在原型上定义方法实现了函数复用，又能保证每个实例都有它自己的属性。 12345678910111213141516171819202122232425262728293031function Animal(age) { this.age = age this.colors = [&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;]}Animal.prototype.say = function () { return &quot;hello&quot;}function Cat(age) { // 继承属性 Animal.call(this, age)}// 继承方法Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var calico = new Cat()calico.colors.push(&quot;white&quot;)var blackCat = new Cat()blackCat.colors.push(&quot;black&quot;)calico.say() // &quot;hello&quot;blackCat.say() // &quot;hello&quot;console.log(calico.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;white&quot;]console.log(blackCat.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;] 则为最常用的继承模式 原型式继承 实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。此处借助ECMAScript 5的Object.create()方法实现。 Object.create()接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。 原型式继承可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。 &lt;注&gt; 采用此方法兼容Ie9+、Firefox 4+、Safari 5+、Opera 12+、Chrome 寄生式继承 实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 为了解决组合模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合模式一起使用 &lt;注&gt; 基本不考虑自定义类型和构造函数的情况下可使用。但也不能够做到函数复用。 寄生组合式继承 实现继承的基本思想：通过借用构造函数来继承属性，通过原型链的混成形势来继承方法。避免组合模式调用两次超类型构造函数 1234567891011121314151617181920212223function inheritPrototype(subType, superType){ var prototype = Object.create(superType.prototype); //创建父类原型的一个副本 等同于使用Object.create(superType.prototype) prototype.constructor = subType; //为副本添加constructor属性,弥补重写原型而失去的constructor属性 subType.prototype = prototype; //将创建的对象(副本)赋值给子类的原型}function Animal(name) { this.name = name;}Animal.prototype.sayName = function () { alert(this.name);};function Cat(name, age) { Animal.call(this,name); //继承SuperType this.age = age; //扩展出age属性}inheritPrototype(Cat, Animal);Cat.prototype.sayAge = function () { alert(this.age);};//扩展出sayAge方法var calico=new Cat(&quot;linda&quot;,2);calico.sayName();calico.sayAge(); 普遍认寄生组合式继承为引用类型最理想的继承范式。 ES6实现继承 1234567891011121314151617181920212223242526272829class Animal { //构造函数 constructor(props) { this.name = props.name || &apos;未知&apos;; } eat() { alert(this.name + &quot;在吃东西...&quot;); } } //class继承 class Bird extends Animal { //构造函数 constructor(props) { //调用实现父类的构造函数 super(props); this.type = props.type || &quot;未知&quot;; } fly() { alert(this.name + &quot;在飞...&quot;); } } var myBird = new Bird({ name: &apos;鹦鹉&apos; }) myBird.eat() myBird.fly() &lt;附&gt; 什么是引用类型？ 基本类型(number,string,boolean,null,undefined)之外就是引用类型 存储上的区别？ 基本类型的变量是存放在栈区的（栈区指内存里的栈内存） 引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存变量标识符和指向堆内存中该对象的指针，也可以说是该对象在堆内存的地址","link":"/2019/06/09/JavaScript/JavaScript实现继承的几种方式/"},{"title":"JavaScript基础巩固篇","text":"“好记性不如烂笔头”夯实基础，提高效率，深耕底层，精细打磨，优化产出。 如何区分数组和对象？ 通过Object.prototype.toString.call()方法来识别 12Object.prototype.toString.call([]) // &quot;[object Array]&quot;Object.prototype.toString.call({}) // &quot;[object Object]&quot; 通过ES6中的Array.isArray()方法来识别 12Array.isArray([]) // trueArray.isArray({}) // false 通过instanceof运算符来识别 12console.log({} instanceof Array) // false console.log([] instanceof Array) // true 通过原型方式，检测A是否继承自Object.prototype或Array.prototype来识别 1234Array.prototype.isPrototypeOf({}) // falseArray.prototype.isPrototypeOf([]) // trueObject.prototype.isPrototypeOf({}) // trueObject.prototype.isPrototypeOf([]) // false 通过constructor属性来区别 12[].constructor // ƒ Array() { [native code] }({}).constructor // ƒ Object() { [native code] } 判断是否为空空对象？ 通过Object.keys()来区别 12const a = {}Object.keys(a).length // 是否为0 数组的迭代方法有哪些？ 参考：http://www.imooc.com/article/277859 遍历对象的方式有哪些？ 参考：https://www.cnblogs.com/wangdashi/p/9606182.html 字符串转化 ‘abcd’变为{d:{c:{b:”a”}}} 1234567const str = &apos;abcd&apos;const newObj = str.split(&apos;&apos;).reduce(function(prev, next){ const obj = {} obj[next]=prev return obj})console.log(newObj) //{d:{c:{b:&quot;a&quot;}}} 实现继承的几种方式： 参考：实现继承的几种方式 闭包: 1 严格模式： 严格模式下对保留字增加限制； 给未声明的变量赋值在严格模式下会导致抛出ReferenceError错误； 在严格模式下不能定义名为eval或arguments的变量，否则会导致语法错误； 数据类型： Undefined、Null、Object、Number、String、Boolean 对象转数组: 123456789101112var obj = { a: 1, b: 2, c: 3}var arr = []for (let i in obj) { let o = {}; o[i] = obj[i]; arr.push(o)}console.log(arr) // [{a: 1}, {b: 2}, {c: 3}] 数组转对象： 1234567891011121314151617// 1.Object.assign 2.扩展运算符（...）const arr = [1, 2, 3]Object.assign({},[1,2,3]) // {0: 1, 1: 2, 2: 3}{...[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]} // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}// forEachlet obj = {}const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]arr.forEach((item,index)=&gt;{obj[index] = item}) // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;}// for...inlet obj = {}const arr = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]for(var key in arr){ obj[key]=arr[key]}obj // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;} #未完待续#","link":"/2019/06/25/JavaScript/JavaScript基础巩固篇/"},{"title":"Javascript内存管理","text":"总结Javascript内存相关知识，加深学习和理解。 .red{color:red;} 回顾基础知识: 基本数据类型：Undefined、Null、Boolean、Number、String、Symbol 引用数据类型：Function、Array、Object 重点: 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中。 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本。 引用类型的值是对象，保存在堆内存中。 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针。 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象。 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符 优化内存: 为执行中的代码只保存必要的数组。一单数据不再有用，最好通过将其值设置为null来释放其引用－－解除引用。适用于大多数全局变量和全局对象的属性。局部变量会在离开执行环境时自动被解除引用。 12let obj = new dialog()obj = null 注：解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。 浏览器中提供window全局方法来手动启用垃圾回收机制，但不建议使用。 补充 堆内存(heap)和栈内存(stack)区别: 在栈内存的数据的大小及生存周期是必须确定的、其优点是寄存速度快、栈数据可以共享、缺点是数据固定、不够灵活 只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享 思考&amp;扩展 副本？ 指针？ 堆栈？ 变量生命周期？ 传值还是引用？ 深浅拷贝 #未完待续#","link":"/2019/08/29/JavaScript/Javascript内存管理/"},{"title":"JavaScript的set和get","text":"JavaScript如何定义赋值？赋值的方式有哪些？ ES6的set和get： 1234567891011121314151617class MyClass { constructor () { this.data = {} } set prop (value) { this.data = value } get prop () { return this.data }}const test = new MyClass()test.prop = 123test.prop // output:&apos;123&apos; ES6的set和get： 12345678910111213let book = { _year: 2020, edition: 1}Object.defineProperty(book, &apos;year&apos;, { get: function () { return this._year }, set: function (newValue) { this._year = newValue this.edition++ }}) &lt;附&gt; ES6的Symbol的key的实现","link":"/2021/01/11/JavaScript/JavaScript的set和get/"},{"title":"WebWorker使用","text":"test","link":"/2021/01/28/JavaScript/WebWorker使用/"},{"title":"this机制","text":"从提出问题、解决问题、this机制引发的问题、es6中箭头函数原理及需要注意点结合函数作用域及执行环境，从原理刨析this底层机制。 提出问题：","link":"/2020/09/02/JavaScript/this机制/"},{"title":"如何手动实现form表单提交的url","text":"这个问题比较有趣，记录一下！ 遇到这个问题很多人的第一反应就是这不就是拼接个字符串吗？是的，没有错！ 但当需要拼接的参数非常多时，比如是个对象，对象中的属性有十几二十个，手动一个个写“&amp;”看起来并不那么smart~而且费时费力，容易出错，代码维护性也不高。 那该如何去写呢？ 方法: Object.entries(for…in) + map 1234567891011121314const params = { a: 1, b: 2, c: 3, d: 4}const paramsString = Object.entries(params).map(item =&gt; { return item[0] + &apos;=&apos; + item[1]}).join(&apos;&amp;&apos;)const url = &apos;https://www.google.com?&apos; + paramsString// output: https://www.google.com?a=1&amp;b=2&amp;c=3&amp;d=4 &lt;附&gt; Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性） Object.entries()示例 12const obj = { foo: &apos;bar&apos;, baz: 42 };console.log(Object.entries(obj)); // [ [&apos;foo&apos;, &apos;bar&apos;], [&apos;baz&apos;, 42] ] Object.entries()和for…in对比 Object.entries()不支持IE，其他浏览器支持性也没for…in好，故用的也比较少。for…in兼容性除ie6以下都兼容，兼容性好很多。应优先选用for…in","link":"/2019/09/04/JavaScript/如何手动实现form表单提交的url/"},{"title":"宏任务和微任务","text":"我们可以将每次执行栈执行的代码当做是一个宏任务(包括每次从事件队列中获取一个事件回调并放到执行栈中执行)， 每一个宏任务会从头到尾执行完毕，不会执行其他 我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务， 而微任务可以理解成在当前宏任务执行后立即执行的任务 常见的宏任务 主代码块 setTimeout setInterval setImmediate ()-Node requestAnimationFrame ()-浏览器 常见微任务 Promise.then() process.nextTick ()-Node catch finally Object.observe MutationObserver 宏任务和微任务注意点： 浏览器会先执行一个宏任务，紧接着执行当前执行栈产生的微任务，再进行渲染，然后再执行下一个宏任务 微任务和宏任务不在一个任务队列，不在一个任务队列 &lt;附&gt; 参考： https://juejin.cn/post/6844904050543034376 https://cloud.tencent.com/developer/article/1701427","link":"/2021/01/07/JavaScript/宏任务和微任务/"},{"title":"手写一个compose","text":"从右到左循环调用 1234567function compose (...args) { return function (x) { return args.reduceRight((prev, cur) =&gt; { return cur(prev) }, x) }} 测试一下： 12345678910function toUpperCase (str) { return str.toUpperCase()}function add (str) { return str += &apos;!&apos;}const fn = compose(add, toUpperCase)console.log(fn(&apos;hello&apos;)) // &apos;HELLO!&apos;","link":"/2021/01/13/JavaScript/手写一个compose/"},{"title":"手写一个reduce","text":"reduce累加器的js实现 123456789Array.prototype.myReduce = function (callback, initVal) { const arr = this arr.forEach((item) =&gt; { initVal = callback(item, initVal) }) return initVal} 测试一下： 1234567const datas = [4, 8, 15, 16, 23, 42]const sum = datas.myReduce(function (prev, next) { return prev + next}, 0)console.log(sum) // 108","link":"/2021/01/13/JavaScript/手写一个reduce/"},{"title":"手写一个简易版promise","text":"promise解决的问题：javascript是单线程，避免阻塞。 .red {color: red;} .blue {color: blue;} 解决的问题有： 嵌套调用，第一个函数的输出往往是第二个函数的输入； 处理多个异步请求并发，开发时往往需要同步请求最终的结果。 运用到的设计模式： 发布订阅模式：收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const PENDING = &apos;PENDING&apos;const FULFILLED = &apos;FULFILLED&apos;const REJECTED = &apos;REJECTED&apos;class Promise { constructor (executor) { this.status = PENDING this.value = null this.reason = null // 存放依赖 this.onRejectedCallbacks = [] this.onResolvedCallbacks = [] // 触发通知 const resolve = (value) =&gt; { if (this.status === PENDING) { this.status = FULFILLED this.value = value // 执行依赖 this.onResolvedCallbacks.forEach((fn) =&gt; fn()) } } // 触发通知 const reject = (value) =&gt; { if (this.status === PENDING) { this.status = REJECTED this.reason = value // 执行依赖 this.onRejectedCallbacks.forEach((fn) =&gt; fn()) } } try { executor(resolve, reject) } catch (error) { reject(error) } } then (onFulfilled, onRejected) { if (this.status === FULFILLED) { onFulfilled(this.value) } if (this.status === REJECTED) { onRejected(this.reason) } // 收集依赖 if (this.status === PENDING) { this.onResolvedCallbacks.push(() =&gt; { onFulfilled(this.value) }) this.onRejectedCallbacks.push(() =&gt; { onRejected(this.reason) }) } }} 测试一下： 1234567new Promise((resolve, reject) =&gt; { resolve(&apos;success&apos;)}).then((data) =&gt; { console.log(data) // &apos;success&apos;}, (err) =&gt; { console.log(err)}) 123456789new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos;success&apos;) }, 100)}).then((data) =&gt; { console.log(data) // &apos;success&apos;}, (error) =&gt; { console.log(error)}) Promise.all：按队列依次返回结果 1234567891011121314151617const promise1 = new Promise((resolve, reject) =&gt; { setTimeout(resolve, 1000, &apos;promise1&apos;)})const promise2 = new Promise((resolve, reject) =&gt; { setTimeout(resolve, 2000, &apos;promise2&apos;)})const promise3 = new Promise((resolve, reject) =&gt; { setTimeout(resolve, 3000, &apos;promise3&apos;)})Promise.all([promise1, promise2, promise3]).then((result) =&gt; { console.log(result) // [&quot;promise1&quot;, &quot;promise2&quot;, &quot;promise3&quot;]}).catch((error) =&gt; { console.log(error)}) 手写一个Promise.all 12345678910111213function all (promises) { return new Promise((resolve, reject) =&gt; { var result = [] promises.forEach((promise) =&gt; { promise.then((values) =&gt; { result.push(values) result.length === promises.length &amp;&amp; resolve(result) }, (error) =&gt; { reject(error) }) }) })} 测试一下： 12345all([promise1, promise2, promise3]).then((result) =&gt; { console.log(result) // [&quot;promise1&quot;, &quot;promise2&quot;, &quot;promise3&quot;]}).catch((error) =&gt; { console.log(error)}) Promise.race：采用第一个promise的值作为它的值。无论堆栈中后面的promise是resolve还是reject都会取第一个返回的结果 返回结果与Promise的结果(resolve和reject)无关，仅与返回的顺序。 promise中存在setTimeout，会影响返回结果。 手写一个Promise.race 123456789101112131415function race (promises) { var hasValue = false var hasError = false return new Promise((resolve, reject) =&gt; { promises.forEach(promise =&gt; { promise.then((value) =&gt; { !hasValue &amp;&amp; !hasError &amp;&amp; resolve(value) hasValue = true }, (error) =&gt; { !hasValue &amp;&amp; !hasError &amp;&amp; reject(error) hasError = true }) }) })} 测试一下： 123race([promise1, promise2, promise3]).then(values =&gt; { console.log(values) // &quot;promise1&quot;}) Promise.allSettled：返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。 123456Promise.allSettled([promise1, promise2, promise3]).then((result) =&gt; { result.forEach(item =&gt; console.log(item)) // {status: &quot;fulfilled&quot;, value: &quot;promise1&quot;} // {status: &quot;fulfilled&quot;, value: &quot;promise2&quot;} // {status: &quot;fulfilled&quot;, value: &quot;promise3&quot;}}) 只要其中的一个 promise 成功，就返回那个已经成功的 promise：只要其中的一个 promise 成功，就返回那个已经成功的 promise。 123Promise.any([promise1, promise2, promise3]).then((value) =&gt; { console.log(value);}) Promise.resolve： 1Promise.resolve(5).then((values) =&gt; {console.log(values)}) // &quot;5&quot; Promise.reject： 1Promise.reject(&apos;error&apos;).then(()=&gt;{}, (error)=&gt; {console.log(error)}) // &quot;reject&quot; &lt;附&gt; https://promisesaplus.com/ https://github.com/promises-aplus https://www.promisejs.org/patterns/","link":"/2021/01/13/JavaScript/手写一个简易版promise/"},{"title":"深拷贝&浅拷贝","text":"&lt;附&gt; 参考： https://juejin.cn/post/6908606240356581389","link":"/2020/12/21/JavaScript/深拷贝&浅拷贝/"},{"title":"请求后台数据的几种方式","text":"XHR(XMLHttpRequest)、Ajax、Axios和Fetch介绍和比对。 XMLHttpRequest对象用于在后台与服务器交换数据(ajax的原生实现) 1234567891011121314151617181920212223242526272829303132333435363738394041424344var xmlhttp;function loadXMLDoc(url){ xmlhttp=null; if (window.XMLHttpRequest) { xmlhttp=new XMLHttpRequest(); } else if (window.ActiveXObject) { // for IE5 and IE6 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } if (xmlhttp != null) { xmlhttp.onreadystatechange=state_Change; // Get请求 xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(null); // POST请求 &lt;!-- xhr.open(&apos;POST&apos;, &apos;/user/login&apos;); xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); var param = { name = &apos;peter&apos; } xmlHttp.send(param) --&gt; } else { alert(&quot;Your browser does not support XMLHTTP.&quot;); }}function state_Change(){ if (xmlhttp.readyState==4) { // 4 = &quot;loaded&quot; if (xmlhttp.status==200) { // 200 = OK console.log(JSON.parse(xhr.responseText)) } else { alert(&quot;Problem retrieving XML data&quot;); } }} more： http://www.w3school.com.cn/xml/xml_http.asp https://www.cnblogs.com/aimeeblogs/articles/9501946.html JQuery Ajax 基于对原生XHR的封装，除此以外还增添了对JSONP的支持 12345678$.ajax({ type: &apos;POST&apos;, url: url, data: data, dataType: dataType, success: function () {}, error: function () {}); 缺点： 本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 1234567891011axios.get(&apos;/user&apos;, { params: { ID: 12345 }}).then(function (response) { console.log(response);}).catch(function (error) { console.log(error);}); Features: 从浏览器中创建XMLHttpRequests 从node.js创建http请求 支持Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF more： https://www.kancloud.cn/yunye/axios/234845 Fetch (需更多了解完善) more：https://segmentfault.com/a/1190000012836882","link":"/2019/07/03/JavaScript/请求后台数据的几种方式/"},{"title":"存疑问题整理","text":"旨在将实际遇到的问题归纳起来，便于后期学习维护 现有组件如何扩展？扩展方式有哪些？ 前端缓存方式有哪些？哪些情形适合做缓存？ 前端缓存分为两部分：http缓存和浏览器缓存 http缓存：强缓存。强缓存主要是采用响应头中的Cache-Control和Expires两个字段进行控制的。 浏览器缓存：Cookie、LocalStorage、SessionStorage、Service Worker Cookie设置: 不设置过期时间，则表示这个cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。 设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。 页面中的一个值通过两个接口的返回值运算得到，两个接口都走异步（返回值获取的时间顺序不可控），如何保证最后的值准确？ 前端数据存储方式有哪些？ 在JavaScript中，数据存储的位置会对代码整体性能产生重大的影响。数据存储共有4种方式:字面量、变量、数组项、对象成员。它们有着各自的性能特点。 访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。 由于局部变量存在于作用域链的起始位置，因此访问局部变量比访问跨作用域变量更快。变量在作用域链中的位置越深，访问所需时间就越长。由于全局变量总处在作用域链的最末端，因此访问速度也是最慢的。 避免使用with语句，因为它会改变执行环境作用域链。同样try-catch语句中的catch子句也有同样的影响，因此也要小心使用。 嵌套的对象成员会明显影响性能，尽量少用。 属性或方法在原型链中的位置越深，访问它的速度也越慢。 通常来说，你可以通过把常用的对象成员、数组元素、跨域变量保存在局部变量中来改善JavaScript性能，因为局部变量访问速度更快。 web服务器有哪些？ Apache、Nginx、Tomcat、IIS、Kangle、WebSphere、WebLogic、Jboss等等 sells方法(sellsian approach)是什么？ H5页面与原生交互的方法 参考：https://www.jianshu.com/p/07f2e1364f35 WebGL 参考：http://www.hewebgl.com/article/getarticle/26 Node http://nodejs.cn/latest-api/events.html koa 参考：https://koajs.com/ 自动化脚本 shell脚本：https://www.cnblogs.com/fozero/p/9134543.html Es5严格模式： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode","link":"/2019/04/23/FQA/存疑问题整理/"},{"title":"typescript基础巩固篇","text":"typescript 元组 Tuple访问越界元素 报错: https://www.dazhuanlan.com/2020/01/15/5e1ea92fcc58d/ TypeScript最佳实践：是否使用strictnullcheck: https://segmentfault.com/a/1190000019775309 typescript 中的接口和类有什么区别: https://segmentfault.com/q/1010000005648974 https://zhuanlan.zhihu.com/p/21629069","link":"/2021/07/26/Typescript/typescript基础巩固篇/"},{"title":"IE及移动端兼容性&其他问题汇总","text":"此篇用于总结遇到的兼容性问题，便于积累和提升 css 透明度opacity:filter:alpha(opacity=50);可支持ie8 尾类::before和::after在ie8下失效 图表绘制：highcharts在绘制图表时，高版本用”canvas”，ie8及低版本用”shape形状” a标签兼容性问题： 1&lt;a href=&quot;javascript:void(0);&quot; target=&quot;_blank&quot;&gt;&lt;/a&gt; firfox会新开空白页面，避免使用这种写法 overflow:hidden会清除浮动 @media可用做响应式布局。通常会用到的media type会是all 和screen，然后是print，一些网站会专门通过print类型为页面的打印格式提供更友好的界面。媒体类型支持not和only关键字，它们可以用来更方便的定位某个媒体设备。 详细了解：https://www.cnblogs.com/august-8/p/4537685.html 由于历史原因及某些特殊原因，需通过CSS清除定位position: 1position: static; javascript 字符串比较大小会产生失真; js在比较数字的时候一定不要直接比较。而是要转换，因为JS里面的是var 这种是弱的类型，默认是string，所有比较的时候会出现错误。js里面有两种转换的，parseFloat和parseInt。 number变字符串: ‘’+123 左侧加空字符串 向上取整：Math.ceil() 向下取整：Math.floor() JS去掉字符串中的空格： 去除所有空格: 1str = str.replace(/\\s+/g,&quot;&quot;); 去除两头空格: 1str = str.replace(/^\\s+|\\s+$/g,&quot;&quot;); 去除左空格： 1str = str.replace( /^\\s/, &apos;&apos;); 去除右空格： 1str = str.replace(/(\\s$)/g, &quot;&quot;); 页面种cookie： 1document.cookie = &apos;userId=123;test=456&apos; for循环性能比对： for&gt;forEach&gt;for…in 性能优化： break/continue语句，适时运用 缓存变量（如数组长度） jquery 实时监听input输入框值变化: 123$(&quot;#input1&quot;).bind(&quot;input propertychange&quot;,function(event){ console.log($(&quot;#input1&quot;).val())}); hybrid內嵌h5 Android、IOS的webview均可通过Chrome来仿真，调试兼容性。（html2canvas组件调试在真机测试分享到微信朋友圈时，存在分享页乱掉问题，问题原因定位时，未能及时排除浏览器兼容性问题，造成各端反复定位问题的时间浪费。此处埋个钩子，需要深入学习了解） 多页面跳转时，注意路径问题。（返回路径到指定页面） 多页面跳转时，涉及表单业务时，需考虑页面数据存储。例如：vue框架下可选用vux做数据存储。 for…in慎用：在ios低版本下会循环两次。 textArea/input键盘收缩：在iphone7及以上会出现键盘关闭后，页面不下拉的情况。此时需用blur事件（失去焦点时触发），window.scroll(0,0)做置顶，将页面手动下拉。 a标签中慎用target=”_blank”打开新窗口，会导致链接看起来跳转了两次。 微信公众号 页面开发需经appid身份认证之后，在微信开发者工具中进行开发。 Commit message 和 Change log 编写指南 http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html #未完待续#","link":"/2019/03/06/css/IE及移动端兼容性问题&其他汇总/"},{"title":"函数防抖和节流","text":".mt5 { margin-top: 5px; } .mt10 { margin-top: 10px; } .pt10 { padding-top: 10px; } .red { color: red; } 函数防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。最后一次为准。 函数节流：每隔一段时间，只执行一次函数。 函数防抖： 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。最后一次为准。 12345678910111213141516var timer;function debounce (fn, delay, ...args) { clearTimeout(timer) timer = setTimeout(() =&gt; { console.log(args) fn(args) }, delay)}document.onclick = function () { debounce(testDebounce, 5000, 1111, 2222)}function testDebounce (...args) { console.log(args)} 函数节流： 每隔一段时间，只执行一次函数。 123456789101112131415161718192021222324function throttle (fn, delay) { var previous = 0 // 使用闭包返回一个函数并且用到闭包函数外面的变量previous return function () { var _this = this var args = arguments var now = new Date() if (now - previous &gt; delay) { fn.apply(_this, args) previous = now } }}var testThrottleFn = throttle(testThrottle, 5000) // 节流函数document.onclick = function (e) { testThrottleFn(e, &apos;throttle&apos;) // 给节流函数传参}function testThrottle (e, content) { console.log(e, content)} 函数防抖的应用场景 连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求; 手机号、邮箱验证输入检测; 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染; 函数节流的应用场景 间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听; 谷歌搜索框，搜索联想功能; 高频点击提交，表单重复提交;","link":"/2021/01/11/JavaScript/防抖和节流/"},{"title":"偷影子的人－观感","text":"空闲时间书为伴，每本书如一位好友般娓娓道来。叙述着一段段不同的人生。有平淡的小美好，有跌宕起伏的人生磨难，有历史长河的波澜壮阔，也有生活中平淡无奇的琐事。故将美好的事情记录下来，无论怎样，每一天都值得好好的对待！ 书作者Marc Levy，对作者并不熟悉，暂略。 故事是以一个小男孩的视角去描述的。目前看了二分之一。之所以止住不看，是因为对另一句描述影子的话深感恐惧。一句话有时候可以给人力量，同时也足以让人深感恐惧，所以暂写二分之一的观感。想描述一下光明面的影子。 书中瘦弱的小男孩，拥有“超能力”，能够“偷别人的影子”，能透过影子看到他人，听见人们心中不愿意说出口的秘密。他心中的善良，让他成为需要帮助者的心灵伙伴，为每个“偷来影子的人”找到点亮生命的小小光芒。 故事的开始，小男孩爸爸和妈妈的感情不和，让小男孩家庭破碎，小男孩和妈妈相依生活。小男孩对父亲的爱并没有减少，将思念深藏心底。 伊凡是小男孩的好朋友，也是学校的警卫，在煤气炉爆炸时，小男孩在他人的帮助下救出在煤气炉中的伊凡，救出的伊凡十分痛苦，由于妈妈留给他的最后一封信和照片还在煤气炉中，可能会被烧毁，而小男孩透过那悲伤的影子，知道伊凡从出生就没见到过自己的妈妈。他妈妈在生他时就难产去世了（这块有点老套剧情的意思，忽略）。伊凡瞬间眼角湿润，小男孩回去后找自己的妈妈写了封信，请自己妈妈写出他还没出生时，她想跟他说得话。小男孩小心翼翼的将信藏在了伊凡的煤气炉的箱子底下，足足等了一周，伊凡来找他。伊凡辞职了，来跟他告别，这封信让伊凡意识到了他一直被童年禁锢，他要追寻他美好的人生了。 这段是我目前为止最喜欢的一个情节，心思巧妙动人心弦。其它情节如吕克、伊利沙白、克雷儿相比会稍加逊色。善良的人很多，能够巧妙的让人舒服的善良很难得。而这份善良有可能会改变一个人的一生。 文采不好，将这些文字埋在角落。如有幸您读到了，感恩您花时间阅读。 现在读书的感觉很好，有了部分人生阅历之后，一些浅显的东西也更能看得更深刻，更了解明白作者想表达内容，是件美好的事情。","link":"/2019/05/11/书虫/偷影子的人/"},{"title":"巨人的陨落－观感","text":"《巨人的陨落》与《世界的凛冬》,《永恒的边缘》称为世纪三部曲，巨人的陨落分为三部，断断续续读了第一部的部分章节。整册书浩瀚壮阔，若整书看完写观感，恐有遗漏，故采用边看边写的方式记录这点点滴滴的感悟。 故事是以第三人称描述的，章节紧凑而跌宕起伏。小男孩比利在他十三岁生日那天，开始了他的职业生涯，成为了一名学徒矿工。那天他也要第一次下井工作来贴补家用，下井并不是件轻松的事情，镇子里二十五岁的大卫第一天就在井下哭了鼻子落了个”戴哭宝”的外号。比利希望自己下井时能尽可能像个男子汉一样，不要出丑。 比利的父亲一名矿工代理人，受雇于英国最强大的工人同盟，也可理解为工会，为工人向资本家争取各项权益，维护工人的利益。矿上的人都认识他的父亲，对他父亲也是有人拥护有人憎恨。矿工负责人显然站在了他父亲的对立面。 幼小的比利此时已站在了井口等待下井了，一同的还有与他年龄相当的另一个小男孩，被放在了升降吊笼里。在”砰”的一声爆响后，比利随吊笼的下降害怕到大声尖叫，感觉十分强烈，他就要憋不住眼泪了。边上的小男孩更是一脸刷白。吊笼渐缓，慢慢停了下来，比利颤抖着走了出来。普莱斯负责将他们带到工区，走过马厩时，放下了另一个小男孩，他们继续向另一个更旧、更狭窄的通道走去，在检修口处放下了比利，吩咐比利将垃圾铲到道车里，普莱斯还将自己的矿灯换了比利的矿灯走掉了。 年幼的比利将矿灯放在高处开始干活，殊不知没过会矿灯灭掉了，四周漆黑一片。此时的比利惊恐而害怕，万般绝望下想到了妈妈说的在他出门前跟他说的耶稣与你同在，无奈下比利唱起了颂歌，同时按惯性将垃圾铲向道车。心想普莱斯会在吃中饭时过来找他。但事实往往更残酷，吃中饭时普莱斯都没来找他，他在漆黑中摸到了妈妈准备的便当，将三明治送入口中周围老鼠一遍遍的顺着他的胳膊爬到他的手跟前，他只能加快吃掉。赶忙吃完中饭后，比利又一次拿起了铁锹唱起了颂歌，将垃圾一次次的铲向了道车。 又过了一段时间，普莱斯来找他了。但同时也被眼前的一幕惊呆了，比利有力的挥舞着铁锹，一面坚定高昂的唱着颂歌。显然，普莱斯因为比利父亲的缘故故意为难比利，而比利却并没有被困难吓到，而是战胜了内心的恐惧，寻求了生的希望。从而也成就了更强大的比利，出井后，比利有了个新绰号，大家叫他”耶稣的比利”。 绝望中寻找希望人生终究辉煌！ 未完待续，书中类似的故事穿插着还有许多，有时间会再整理一些。作者总是在尽可能的形成强烈的对比，来展现出不同人物性格在不同境况表现出来的不同的特征。谨以此篇献给每个热烈活着的鲜活个体，因为你们生命而更绚烂！","link":"/2019/10/10/书虫/巨人的陨落/"},{"title":"上帝掷骰子吗？－观感","text":".td{text-indent:30px;} 遇事不决，量子力学；解释不通，穿越时空；篇幅不够，平行宇宙；时间逆转，热力熵减。","link":"/2020/03/05/书虫/上帝掷骰子吗/"},{"title":"巨人的陨落－观感2","text":".td{text-indent:30px;} 每个人都是自己的掌舵人，都会被世界接纳… 此篇内容来自《巨人的陨落1》中部分章节中情节描述，点滴记录读此篇章时的部分感悟。如有不当，还请指正。 如果把生命比作一段旅程，这段旅程中有开心、有难过、有感动、有悲伤…不同的感情温度对应不同的色值，有些感情饱满而深厚，有些平淡无华，有些波折难熬，有些幸福难忘……随着时间流逝，日渐模糊了记忆，褪去了浮华，凝结成属于每个人每个生命体的本原色，也造就了个体的不同属性。 故事要从煤矿发生爆炸说起，爆炸的起因可能有多种，矿井下通风不畅甲烷浓度过高，稍有不慎便会引发爆炸，爆炸引发粉尘燃烧进而引发火灾，矿工身处八百米以下头上有数百万吨的土石只有很少木梁支撑的地下，由于矿厂主为了降低成本“呼吸器”等设备并不齐全，缺氧和火灾会使矿工岌岌可危，这也是矿工们最担心的一件事情。 此刻菲茨伯爵的梅费尔宅邸中正在宴请国王，精致的器皿，精心搭配的水果餐食及按不同喜好布置的精致房屋，在“轰”的一声中，将聚会的欢乐时光一扫而光。矿难造成八人死亡，另五十人伤势严重。艾尔瑟是比利的姐姐，同时也是菲茨伯爵家中的女管家。由于矿难，再安排国王列队检阅显得不合时宜，菲茨猜测国王可能会关心一下矿难，便将艾瑟尔引荐给国王，艾瑟尔在表达自己的见解后提出了一个更为大胆的建议“访问死者家属…” 马车驶出豪华的大铁门，门里门外形成了鲜明的反差，门里一切整齐有序，到处是迷人的美景，外面则是一片现实的丑陋。在国王访问过后，艾瑟尔请求回家探亲，回家后艾瑟尔父亲对国王访问这场闹剧表示不满。认为这转移了大家对矿厂危险和非法操作的视线，平息了对矿业的愤怒。无形中化解了一场工人运动。 事实也是如此，此后没多久，丧失丈夫的妇人们，因家中无人在矿业做工而惨遭驱散无家可归。而年幼的艾瑟尔对父亲不理解自己为矿难家属做出的感情慰问深感懊恼，在回到伯爵府后向菲茨哭诉。此后菲茨为艾瑟尔非凡的表现而倾心，他们之间有过快乐的时光，之后却在自己的妻子碧公主和艾瑟尔同时怀孕时无情的抛弃了艾瑟尔。正当艾瑟尔走投无路之时回到家中，由于她父亲年幼时背负了祖父母名誉的影响极度愤怒，并将艾瑟尔赶出家门。艾瑟尔整理好行李便赶去伦敦的火车，比利送她去了车站。 章节中还穿插了菲茨的妹妹茉黛的感情线，她和沃尔特相爱，但却因政治原因备受左右及奥托父亲对茉黛特立独行的行为举止不满意，沃尔特出生在德国的外交世家，父亲奥托身处要职，而德国与英国的外交紧张近乎敌对状态，一旦沃尔特娶了英国人，他的家族将不受该阶层的信任，沃尔特也将无法在他的外交事业上施展才华。迫使相爱的两个人想要在一起遇到重重困境。 另一侧格戈雷里的父亲因为在碧公主的土地上放牛，而被指侵犯特权无情处死，格戈雷的母亲在一场工人斗争中被无情镇压而亡，格戈雷里和弟弟相依为命，攒了9年去美国的船票钱，那是他对一切未来的希望，而在即将上船的那刻，他弟弟因谋杀而无法呆在俄国，向他请求将船票给他，那刻他迟疑了片刻便将护照船票生活费倾尽所有的给了弟弟…弟弟满怀希望的坐船去美国赚钱给哥哥攒船票，几天几夜后偷渡船并没有把他放在美国，而是更近的临近国家…（偷渡船为了赚钱而欺骗了大家… 书中细节部分的描述强烈的烘托形成了鲜明的对比，将上层社会的冷漠现实和下层人民的贫穷疾苦多灾多难淋淋尽致的表现出来，不偏不倚的描述出世界的两面，对两面的描写是如此的细致入微而客观，精彩的转折将人物的性格和感情表达的直观而强烈。展现出历史背景下无人幸免的悲苦世界的同时，又描述出生命本真的每个人的内心渴求。","link":"/2020/01/27/书虫/巨人的陨落－观感2/"},{"title":"跨平台多端适配","text":"&lt;附&gt; Weex:https://weex.apache.org/zh/","link":"/2021/01/07/兼容性问题处理/多端适配/"},{"title":"函数式编程","text":"Haskell: https://www.w3cschool.cn/hsriti/ React： 函数式编程","link":"/2021/03/15/函数式编程/Haskell/"},{"title":"活着－观感","text":".td{text-indent: 30px;} .tc{text-align: center;} .tt{margin-top: 50px;} 苦难催人成长，坚韧历练心性，浮浮沉沉此乃人世间。 《活着》作者余华，通过描绘主人公福贵起起伏伏的一生，进而进一步描绘出一个人面临抉择的无奈和生命的脆弱，作者借此 鼓励历经苦难和正在经历痛苦的人们，体味人性之光，乐观生活。 如果一个人正在经历苦难，可以读读活着…你会感觉其实你所经历的痛苦或许没有那么艰难。主人公福贵，从阔少爷赌博败光 家产，以至于后来女儿因没钱治病而高烧失聪，为了让儿子上学，曾将女儿送给别人家，而儿子在学校却嬉戏玩耍不用功，女儿后来 自己从别人家跑回来，儿子却因为学校捐血而丧命。女儿欢欢喜喜的结婚，却因为难产而丧命。白发人送黑发人，送完家里的老人又 送完孩子，只有老婆家珍陪伴着他，最后连家珍也因病丧命。独留福贵一人，福贵买了一匹老马陪他度过这后面的余生。 但反过来看，就像福贵并没有因为输光家产而沮丧，而是买了田地，下地干农活为一家人的生计奔波。在妻儿承受重大苦难时， 能够挑起身为人父身为人夫的重担。在经历人生重大变故时，依然能够不放弃生命，混迹在这孤独的人世间。变故的发生往往是始料 不及的，但值得学习的是面对这些事情之后，对事情的处理以及反思。 人这一生要经历的变故很多，不可能一帆风顺，有高兴有悲伤有欢乐也有痛苦。没有一次次的磨难，就不能体会到当下的平安和 祥和是多么的难能可贵。进而无从去谈如何珍惜当下，正视苦难并克服困难，给自己以勇气赋明天以希望，进而得以活在这人世间。 题都城南庄 去年今日此门中，人面桃花相映红。 人面不知何处去，桃花依旧笑春风。","link":"/2021/11/04/书虫/活着/"},{"title":"Git使用过程中遇到的问题","text":"此篇用于记录Git使用过程中遇到的问题。 .pt{padding-top:10px;} .pt5{padding-top:5px;} .fb{font-weight:bolder;} 多个公私密钥情况下，如何添加ssh-add？ 起因：出于安全考虑，我的github和公司内部的git分别用两套ssh生成的公私密钥，在使用过程中，由于ssh-add不是永久的，切换后反复需要再次加上，费时费力。 解决方式：通过如下方式，将key加入keychain中解决 1ssh-add -K ~/.ssh/keyname 参考：https://segmentfault.com/q/1010000000835302 如何撤销rebase？ 起因： 在rebase过程中，操作失误，将conflict合并至本地分支，当然可以通过处理冲突后再commit方式来解决，但无疑多增加了一次不必要的commit，因此考虑撤销rebase再来rebase一次。 解决方式：git reflog + git reset –hard 12git reflog git reset --hard HEAD@{index} // 如 index=rebase前的索引 参考：https://www.cnblogs.com/suanec/p/7511137.html Add all files to a commit except a single file? 12git add -ugit reset -- XXX.txt 撤销push到远程的某个文件的commit同时清除历史？ 查看本地分支和远程分支 12git branch // 本地分支git branch -r // 远程分支 删除本地分支和远程分支 123456// 本地分支git branch -D BranchName// 远程分支git branch -r -D origin/BranchNamegit push origin -d BranchName 查看两个branch差异？ 查看A有B没有 1git log A ^B 查看B有A没有 1git log B ^A 查看A比Bd多了哪些？ 1git log A..B 查看B比A多了哪些？ 1git log B..A 在上线发布前对比master分支时，需要确认一下分支情况。 直接将两个分支上最新的提交做diff 12git diff topic mastergit diff topic..master 参考：https://blog.csdn.net/u011240877/article/details/52586664","link":"/2019/09/04/工具/Git使用过程中遇到的问题/"},{"title":"VSCode常用快捷键","text":"快捷键 操作 shift + alt +up/down 复制当前行 alt + up/down 移动行 command + b 显示/隐藏左侧目录栏 shift + command + k 删除当前行 command + ~ 控制台终端显示与隐藏 alt + shift + A 多行注释 command + [ 行增加缩进 command + ] 行减少缩进 command + ( + 或 - ) 字体放大/缩小 command + shift + left/right 切换窗口 command + w 关闭编辑器窗口 command + k + w 关闭所有窗口","link":"/2019/10/17/工具/VSCode常用快捷键/"},{"title":"unit-tests","text":"I don’t always bend time and space in unit tests, but when I do, I use Buster.JS + Sinon.JS &lt;附&gt; https://sinonjs.org/ https://www.zcfy.cc/article/sinon-tutorial-javascript-testing-with-mocks-spies-stubs-422.html","link":"/2019/10/27/工具/unit-tests/"},{"title":"babel编译过程","text":"","link":"/2019/10/17/工具/babel编译过程/"},{"title":"Mac安装和卸载HomeBrew","text":"Homebrew(to:official website):是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。 最近不小心动了这个，把Homebrew本地包删成了个残缺包，so 想办法重装，遇到了些许问题，记录下来。 安装 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 卸载 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)&quot; &lt;附&gt; 二次安装中遇到的问题 当遇到 Error: Checksum mismatch. 类似校验不匹配的错误报错信息时: 如图所示，出现这种报错信息时，直接使用控制台命令，删除已经下载的文件(红色箭头处)。 如：rm -rf /Users/sunhui/Library/Caches/Homebrew/portable-ruby-2.3.7.mavericks.bottle.tar.gz 然后重新安装即可。","link":"/2019/07/21/工具/Mac安装和卸载HomeBrew/"},{"title":"webpack打包过程","text":"","link":"/2021/01/14/工具/webpack打包过程/"},{"title":"webpack编译过程","text":"","link":"/2019/10/17/工具/webpack编译过程/"},{"title":"手动实现一个koa-logger中间件","text":"koa2对async/await支持。 .red { color: red; } 编写koa-logger.js文件 12345678module.exports = async (ctx, next) =&gt; { const start = new Date().getTime() // 中间件异步处理 await next() const end = new Date().getTime() // 打印出耗时还有长度 console.log(ctx.request.url, end - start, ctx.body.length, &apos;log&apos;)} 注册koa-logger中间件 12345678const Koa = require(&apos;koa&apos;)const app = new Koa()const logger = require(&apos;./koa-logger&apos;)// 注册中间件app.use(logger) koa2核心原理：compose通过递归对中间件队列进行了反序遍历 &lt;附&gt; Node.js中间件模式: https://juejin.cn/post/6844903619209199624","link":"/2021/01/19/工具/手动实现一个koa-logger中间件/"},{"title":"编写自己的webpack Loader","text":"https://www.webpackjs.com/contribute/writing-a-loader/","link":"/2021/01/01/工具/编写自己的webpack-loader/"},{"title":"编写自己的webpack Plugins","text":"https://www.webpackjs.com/contribute/writing-a-plugin/","link":"/2021/01/01/工具/编写自己的webpack-plugins/"},{"title":"工程化概述","text":"&lt;附&gt; 参考： https://juejin.cn/post/6844903588553048077","link":"/2020/12/21/工程化/工程化概述/"},{"title":"Performance Monitor性能指标","text":"查看性能指标，页面性能调优。 CPU usage, CPU占用率 JS head size, JS内存使用大小 DOM Nodes, 内存中挂载的DOM节点个数 JS event listeners, 事件监听数 &lt;附&gt; https://juejin.cn/post/6844904045774110733","link":"/2021/01/10/异常&性能/Performance-Monitor性能指标/"},{"title":"npm包打包发布","text":"记录封装一个npm包，发布与下载过程。 默认已有https://www.npmjs.com/ 账号 创建本地文件夹，并npm init初始化包信息； 12mkdir test // 创建test文件夹npm init // 完善包文件信息 登录npm: 1234npm login 或 npm adduser(adduser为login别名)// 输入Username、Password、Email// 使用whoami命令将会显示用户名 发布npm包: 1npm publish npm包更新: 1npm update // 注：此处需要更新package.json文件中的版本号version 撤销发布npm包: 12npm unpublish &lt;package&gt;@0.0.1 // 撤销具体某一版本发布npm unpublish &lt;package&gt; --force // 撤销整个包 退出登录npm: 1npm logout npm包发布使用: npm包安装： 1npm install &lt;package&gt;","link":"/2021/08/08/工程化/npm包打包发布/"},{"title":"前端异常处理","text":"&lt;附&gt; http://jartto.wang/2018/11/20/js-exception-handling/ https://juejin.cn/post/6875955097864994823","link":"/2021/01/10/异常&性能/前端异常处理/"},{"title":"前端性能优化","text":"本文主要记录前端性能优化中，可采用的优化点。文中部分观点来自《高性能JavaScript编程》 JavaScript篇 body闭合标签之前，将所有的script标签放到页面底部。这能确保在脚本执行前页面已经完成了渲染。 合并脚本。页面中的script标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。 有多种无阻塞下载JavaScript的方法： 使用script标签的defer属性； 使用动态创建的script元素来下载并执行代码； 使用XHR对象下载JavaScript代码并注入页面中。 css篇 用精灵图处理图标。 减少重排与重绘 网络篇 CDN缓存 HTPP响应缓存头： 最常见的就是 ETag 和 Cache-Control 12345678Cache-Control: public max-age=3600 //本地缓存和 CDN 缓存均缓存 1 小时；Cache-Control: private immutable //不能缓存在 CDN，只能缓存在本地。并且一旦被缓存了，则不能被更新；Cache-Control: no-cache //不能缓存。如果一定要缓存的话，确保对其进行了二次验证；Cache-Control: public max-age=3600 s-maxage=7200 //本地缓存 1 小时，CDN 上缓存 2 小时；Cache-Control: public max-age=3600 proxy-revalidate //本地和 CDN 均缓存 1 小时。但是如果 CDN 收到请求，则尽管已经缓存了 1 小时，还是要检查源 其他 关于html，css，js三者的加载顺序问题： 参考：https://www.cnblogs.com/yingsong/p/6170780.html 浏览器缓存机制： 参考：https://www.cnblogs.com/softidea/p/5308489.html","link":"/2019/05/10/异常&性能/前端性能优化/"},{"title":"JavaScript引擎","text":"","link":"/2021/09/13/引擎/JavaScript引擎/"},{"title":"SEO原理","text":"https://juejin.cn/post/6844903616772309000","link":"/2021/01/01/总结/SEO原理/"},{"title":"使用Hexo+Github搭建属于自己的blog","text":"一直想搭建属于自己的blog，经过查看多方资料比较后，采用Hexo+Github搭建一套免费的blog.(当然你也可以买域名租服务器来实现) 网上的教程很多，就不罗列了，感兴趣的小伙伴可以多方查看参考。 主要参考文章有： hexo官网 使用Hexo+Github一步步搭建属于自己的博客（基础） 优化 热更新：https://github.com/hexojs/hexo-browsersync &lt;附&gt; 常用命令 hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。 hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo new “postName” #新建文章 hexo d -g #生成部署git 配置文件 config.xml里的per_page，这个设置成0就全都没有分页了。 Questions 解决hexo渲染的html页面中有br的问题 只需要在_config.yml里增加如下配置即可 12marked: breaks: false 参考：http://1900.live/rep-hexo-marked/ md文件插入代码片段 参考：https://www.jianshu.com/p/366ff564a8f2 后期完善(评论、站点统计)参考：https://segmentfault.com/a/1190000016267344 node版本：12.14.1","link":"/2019/02/18/总结/使用Hexo-Github搭建属于自己的blog/"},{"title":"前端跨域解决方案","text":"浏览器同源策略：协议、域名、端口都相同触发同源策略限制。 document.domain + iframe跨域 location.hash + iframe跨域 window.name + iframe跨域 window.postMessage跨域 JSONP跨域 CORS跨域资源共享 Nginx代理跨域 Node代理跨域 WebSocket跨域 &lt;附&gt; 参考： https://juejin.cn/post/6850037265595858952#heading-23","link":"/2021/01/01/总结/前端跨域解决方案/"},{"title":"Docker常用命令","text":"Docker常用命令 查看容器的运行状态 1docker ps 与容器进行交互 1docker exec -t -i &lt;容器 ID&gt; /bin/bash 停止一个容器 1docker stop &lt;容器 ID&gt; 重启一个容器 1docker restart &lt;容器 ID&gt; 重命名一个容器 1docker rename &lt;旧容器名&gt; &lt;新容器名&gt; 删除一个容器 1docker rm &lt;容器 ID&gt; &lt;附&gt; 参考： https://www.jianshu.com/p/dbc59702f0dd 创建新Docker容器时出现“The container name “/xxx” is already in use by container xxxxxxxxxxx…”304网络资源占用问题的解决办法。 处理方式：执行 使用 docker system prune 清理掉各类残余的资源。","link":"/2021/03/04/持续集成/Docker常用命令/"},{"title":"实现一个简单的模板引擎","text":"一道面试题 编写add方法，让结果符合预期 add(2, 5); // 7 add(2)(5); // 7 实现一个简单的模板引擎 1234567891011let template = &apos;我是{{name}}，年龄{{age}}，性别{{sex}}&apos;;let data = { name: &apos;姓名&apos;, age: 18};render(template, data); // 我是姓名，年龄18，性别undefined 非递归实现 123Object.keys(param_list).forEach(key =&gt; { template = template.replace(new RegExp(`{${key}}`, &apos;g&apos;), data[key])}) 递归实现 12345678910111213function render(template, data) { const reg = /\\{\\{(\\w+)\\}\\}/; if (reg.test(template)) { const name = reg.exec(template)[1]; template = template.replace(reg, data[name]); return render(template, data); } return template;}","link":"/2021/01/30/引擎/实现一个简单的模板引擎/"},{"title":"Jenkins搭建","text":"","link":"/2021/03/07/持续集成/Jenkins搭建/"},{"title":"Kubernetes（K8s）学习笔记","text":"容器编排是指对单独组件和应用层的工作进行组织的流程，也是指对容器的创建、部署、销毁、网络处理、故障转移等管理行为。容器编排将很多对于容器的操作进行自动化，精细化，降低了管理大量容器的难度。","link":"/2021/03/07/持续集成/Kubernetes（K8s）学习笔记/"},{"title":"搭建前端监控平台","text":"前端监控和前端埋点方案设计 https://juejin.im/post/6844903650603565063 sentry – 前端监控平台 自行搭建前端监控平台： https://develop.sentry.dev/sdk/overview/ https://sentry.io/welcome/ 从零开始写一个前端数据埋点工具 https://juejin.im/post/6844903889938956302","link":"/2021/03/07/持续集成/搭建前端监控平台/"},{"title":"Linux操作系统","text":"浅谈POSIX &lt;附&gt; https://zhuanlan.zhihu.com/p/61774373 https://zhuanlan.zhihu.com/p/392588996","link":"/2021/01/13/操作系统/Linux操作系统/"},{"title":"Unix操作系统","text":"","link":"/2021/01/13/操作系统/Unix操作系统/"},{"title":"构思可视化图表库","text":"&lt;附&gt; 参考： https://mp.weixin.qq.com/s/c9YbqXrf4q5n-Tei0xhLUA","link":"/2021/11/02/数据可视化/构思可视化图表库/"},{"title":"对低代码搭建理解","text":"&lt;附&gt; 参考： https://zhuanlan.zhihu.com/p/161783546","link":"/2021/10/29/数据可视化/对低代码搭建理解/"},{"title":"mongodb","text":"","link":"/2021/01/13/数据库/mongodb/"},{"title":"mysql","text":".red{color:red;} 数据库常用sql整理。 创建数据库: 1234CREATE DATABASE &lt;数据库名&gt;;// 创建notebook数据库mysql&gt; CREATE DATABASE notebook; 显示数据库列表: 123SHOW DATABASES;mysql&gt; SHOW DATABASE; 显示库中的数据表: 123SHOW TABLES;mysql&gt; SHOW TABLES; 选择数据库: 1234use &lt;数据库名&gt;;// 选择notebook数据库use notebook; 删除数据库: 1234DROP DATABASE &lt;数据库名&gt;;// 删除notebook数据库mysql&gt; DROP DATABASE notebook; 创建数据表: 1CREATE TABLE &lt;数据表名&gt; (column_name column_type); 显示表中的记录: 1SELECT * FROM &lt;数据表名&gt;; 删除数据表数据: 1DELETE FROM &lt;数据表名&gt;; 删除数据表: 1DROP TABLE &lt;数据表名&gt;; 删除单条数据: 1DELETE FROM &lt;数据表名&gt; WHERE &lt;参数名&gt; = &lt;参数值&gt;; 查询数据: 1SELECT * FROM &lt;数据表名&gt;; 查看表结构: 1show columns from &lt;数据表名&gt;; 常见的数据模型有层次模型、网状模型和关系模型三种。 需要关注问题：最新的加密方式node还不支持，具体版本是哪一版本，具体不能加密的原因是什么？ &lt;附&gt; https://www.liaoxuefeng.com/wiki/1177760294764384/1246617774585536 数据库设计： https://taogenjia.com/2019/11/13/database-system-3-database-design/","link":"/2021/03/04/数据库/mysql/"},{"title":"redis","text":"Redis的三种模式：主从、哨兵、集群 &lt;附&gt; https://zhuanlan.zhihu.com/p/62936527 https://zhuanlan.zhihu.com/p/62947738","link":"/2021/03/07/数据库/redis/"},{"title":"Javascript数组去重和排序","text":".red { color: red; } 数组去重和排序 数组去重: 包含null/undefined es6的Set 123456789function unique (arr) { return [...new Set(arr)]}function unique (arr) { return Array.from(new Set(arr));}unique([&apos;a&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]) // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] indexOf()结合for…of/forEach/for…in 123456789101112const arr = [1, 1, 2, 3, 4, 4, 5, 6, 6];function unique (arr) { const newArr = []; for(let item of arr){ if (newArr.indexOf(item) === -1) { newArr.push(item) } } return newArr} includes()结合for…of/forEach/for…in 12345678910function unique (arr) { const newArr = []; for(let item of arr){ if (!newArr.includes(item)) { newArr.push(item) } } return newArr} 双重for循环，时间复杂度为O(n^2) 123456789101112131415161718function unique (arr) { const newArr = [] let isRepeat = false for (let item of arr) { isRepeat = false for (let newItem of newArr) { if (item === newItem) { isRepeat = true } } if (!isRepeat) { newArr.push(item) } } return newArr} 优化版 1234567891011121314function unique (arr) { const newArr = [] const len = arr.length for (let i = 0; i &lt; len; i++) { for (let j = i + 1; j &lt; len; j++) { if (arr[i] === arr[j]) { j = ++i } } newArr.push(arr[i]) } return newArr} 数组排序 sort() 12345const arr=[1, 11, 2, 3, 6]arr.sort((a, b) =&gt; { return a - b})arr // output: [1, 2, 3, 6, 11] 注：默认排序规则是数组元素字符的Unicode编码排序的，也就是说数组元素会被当做字符串，然后按照字符串的Unicode编码进行升序排列。","link":"/2020/12/13/数据结构&算法/Javascript数组去重和排序/"},{"title":"常见缓存算法和缓存策略","text":"LRU算法 LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。 1javascript实现待补充 &lt;附&gt; LRU算法原理与实践: https://www.jianshu.com/p/720dda0c418f https://zhuanlan.zhihu.com/p/34989978 https://blog.vimge.com/archives/architecture/cache-strategy.html","link":"/2020/12/13/数据结构&算法/常见缓存算法和缓存策略/"},{"title":"数据结构","text":"","link":"/2021/01/01/数据结构&算法/数据结构/"},{"title":"搭建自己的VPN","text":"","link":"/2021/09/26/服务器/搭建自己的VPN/"},{"title":"算法题","text":"常见算法题汇总。 有一个长度为100的数组，请以优雅的方式求出该数组的前10个元素之和 1234567const arr = (new Array(100)).fill(0).map((item, index) =&gt; { return index})const sum = arr.slice(0, 10).reduce((prev, curr) =&gt; { return prev + curr })console.log(sum) // 45","link":"/2021/01/14/数据结构&算法/算法题/"},{"title":"SOA服务架构","text":"","link":"/2021/01/06/架构/SOA服务架构/"},{"title":"Chrome架构","text":"进程线程：https://cloud.tencent.com/developer/news/414508","link":"/2020/04/02/架构/Chrome架构/"},{"title":"meta-programming元编程","text":"","link":"/2021/03/09/架构/meta-programming元编程/"},{"title":"UNIX编程艺术","text":"孔子云：”取乎其上，得乎其中；取乎其中，得乎其下；取乎其下，则无所得矣”。","link":"/2021/01/06/架构/UNIX编程艺术/"},{"title":"koa vs express对比","text":"","link":"/2021/01/05/架构/koa-express/"},{"title":"vue vs react对比","text":"","link":"/2021/01/01/架构/vue-react对比/"},{"title":"微内核架构","text":"","link":"/2021/01/09/架构/微内核架构/"},{"title":"单体应用","text":"","link":"/2021/01/01/架构/单体应用/"},{"title":"微前端","text":"","link":"/2021/01/01/架构/微前端/"},{"title":"微服务架构","text":"https://www.taopoppy.cn/node-microService/","link":"/2021/01/01/架构/微服务架构/"},{"title":"插拔式架构","text":"","link":"/2021/01/06/架构/插拔式架构/"},{"title":"无服务器架构","text":"无意中看到篇软文，对标题和内容的好奇点了进去，其中聊到一些架构相关的点，先mark住后续补充。 千万级流量业务的Serverless实践，看FaaS给前端带来的变化：https://mp.weixin.qq.com/s/oZ8E75CpdinUBGs45byi3Q 深入理解无服务器架构(Faas/Serverless)：https://blog.csdn.net/xialingming/article/details/81369624 &lt;附&gt; 参考： https://aws.amazon.com/cn/blogs/china/iaas-faas-serverless/","link":"/2020/02/18/架构/无服务器架构/"},{"title":"架构、框架和设计模式","text":"","link":"/2021/01/06/架构/架构-框架和设计模式/"},{"title":"Flutter","text":"","link":"/2021/01/02/框架/Flutter/"},{"title":"ReactNative","text":"","link":"/2021/01/02/框架/ReactNative/"},{"title":"Node相关总结","text":"","link":"/2019/11/14/框架/Node相关总结/"},{"title":"React框架学习","text":"小知识点，日常积累 三斜线指令是包含单个XML标签的单行注释。t注释的内容会做为编译器指令使用。 三斜线引用告诉编译器在编译过程中要引入的额外的文件。 https://segmentfault.com/a/1190000038874526","link":"/2021/09/05/框架/React框架学习/"},{"title":"VUE中v-for和v-if不能同时使用的问题","text":"补充：从源码侧分析 https://www.cnblogs.com/showjs/p/11376446.html","link":"/2021/03/15/框架/VUE中v-for和v-if不能同时使用的问题/"},{"title":"编程范式","text":".pt{padding-top: 10px;} .pt5{padding-top: 5px;} .content p.mb5{margin-bottom: 5px;} .red{color: red;} .bd{border: 1px solid #000} .pd{padding: 5px} 基本思想：将程序分别抽象分解为过程、函数、断言、对象和进程，就依次成为过程式、函数式、逻辑式、对象式和并发式。泛型式核心是抽象出算法后与数据分解。 命令范式: 其世界观是：程序由若干行动指令组成的有序列表。 其方法论是：用变量来存储数据，用语句来执行指令。 声明范式: 是人脑思维方式的抽象，即利用数理逻辑或既定规范对已知条件进行推理或运算。 对象范式: 并发范式: 泛型范式: 超级范式: AOP切面范式（多角度看问题）: AOP将程序抽象分解为切面。宏观角度，AOP无非是SoC(Separation of Concerns)原理和DRY(Don’t repeat yourself)原则的一种应用。AOP的横向方向重用弥补了OOP的不足。 抽象与分解的原则：单一化、正交化。每个模块职责明确专一，模块之间相互独立，即高內聚，低耦合（high cohesion &amp; low coupling）。 正交化：在数学中，互为正交的两个向量在彼此方向上投影为零，意味着彼此独立、互不影响。 举个例子：在调用某些对象的方法、读写某些对象的域、抛出某些异常等前后需要用到统一的业务逻辑，诸如日志输出、代码跟踪、性能监控、异常处理、安全检查、事务管理，等等。 解决思路：将每类横切关注点封装到单独的Aspect模块中，将程序中的一些执行点与相应的代码绑定起来。 例如：调用某个对象的方法前后：符合预先指定条件的接入点集合称为切入点；所有以set为命名开头的方法：每段绑定的代码称为一个建议(advice)。 横向关注点指与程序的纵向主流执行方向横向正交的关注焦点。 接入点是附加行为—-建议(advice)的执行点，切入点(pointcut)是指定的接入点(join point)集合，这些接入点共享一段插入代码。切入点与建议组成了切面(aspect)，是模块化的横切关注点 编织是将附加的切面逻辑嵌入到主体应用程序之中的过程。编织分静态编织和动态编织两种。静态编织在编译期、后编译期或加载期嵌入代码，动态编织则在运行期嵌入。 AOP的实施分3步：切面分解、切面实现和切面合成。 OOP只能沿继承树的纵向方向重用，AOP可以沿横向方向重用。 事件驱动: 函数范式: 逻辑范式: 汇总范式: 情景范式:","link":"/2021/01/14/架构/编程范式/"},{"title":"Vue问题总结","text":"常见问题总结 父组件给子组件传props，当props值不需设置时，可传null或者undefined 12345678910111213141516171819202122232425262728293031props: { // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: &apos;hello&apos; } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return [&apos;success&apos;, &apos;warning&apos;, &apos;danger&apos;].indexOf(value) !== -1 } }} 在某个页面中new一个对象时，在离开页面时要注意销毁（设为undefined）,避免对象被实例化多次。 主函数/mixin/组件 生命周期执行过程","link":"/2019/10/28/框架/Vue问题总结/"},{"title":"egg.js","text":"","link":"/2021/01/12/框架/egg-js/"},{"title":"eggjs插件开发与发布","text":"补充：个人插件开发/发布","link":"/2021/03/15/框架/eggjs插件开发与发布/"},{"title":"vue-ssr实现原理","text":"","link":"/2021/01/15/框架/vue-ssr实现原理/"},{"title":"vue3.0新特性","text":"Composition API 数据双向绑定","link":"/2021/01/11/框架/vue3-0新特性/"},{"title":"vue插件开发与发布","text":"补充：个人插件开发/发布 &lt;附&gt; https://www.jianshu.com/p/d6855556cd75","link":"/2021/03/15/框架/vue插件开发与发布/"},{"title":"vue的diff算法","text":"","link":"/2021/01/11/框架/vue的diff算法/"},{"title":"「vue-router源码」页面问题：菜单路由连续点击无响应","text":".pt{padding-top: 10px;} .mt5{margin-top: 5px;} .mt10{margin-top: 10px;} .red{color: red;} .blue{color: blue;} .fb{font-weight: bolder} 页面问题：菜单路由连续点击无响应，该问题在网上有很多其他的处理方式，比如vuerouter改写prototype的push方法做catch等等，但经过对该部分源码的解读及vue-router各版本的update更新点的对比发现，vue-router的版本控制做得不够好，故提出以下解决方案。 问题出现在： vue-router v3.0.7版本后 问题解决方式： package.json 关闭v3版本自动升级，并将版本固定到3.0.7（注：vue-router的版本设计不合理 – promise的引入，应在v4大版本升级时发布，orz现在还在v3系列，v4系列的话，package自动升级就不会受到影响。 解决vue-router报NavigationDuplicated: Avoided redundant navigation to current location 的问题。 触发该报错信息条件： 1// in the case the route map has been dynamically appended to isSameRoute()：match匹配 上次路由索引 与 当前路由索引 全匹配 在2条件满足后，触发vue-router的matched机制 &lt;附&gt; matched机制说明： matched的map源码实现：","link":"/2021/01/15/框架/菜单路由连续点击无响应/"},{"title":"从零搭建vue/react项目","text":"不借助vue-cil脚手架，基于webpack+vue搭建开发环境 github: vue-demo地址： https://github.com/sunhui-blog/vue-demo react-demo地址： https://github.com/sunhui-blog/react-demo 具体步骤: project初始化：npm init生成package.json 安装依赖包：npm i webpack vue vue-loader 实例化vue：index.js文件中实例化vue 配置webpack.config.js：plugins和loader及开发环境 &lt;附&gt; 参考： 不使用cli脚手架搭建vue项目工程(webpack简单配置) 遇到的问题： vue+webpack 执行npm run dev后访问首页显示目录结构的原因 参考解决：https://blog.csdn.net/rpf1234/article/details/103205173 webpack-dev-server启动报错Error: Cannot find module ‘webpack-cli/bin/config-yargs‘ 参考解决： https://juejin.cn/post/6883375553395720199 React hooks: https://juejin.cn/post/6844903975838285838","link":"/2021/01/16/框架/从零搭建vue-react项目/"},{"title":"解决vue引入ElementUI报错","text":"报错信息ERROR in ./node_modules/element-ui/lib/theme-chalk/fonts/element-icons.ttf 解决方式：在webpack.config.js的module/rules中加上 1234{ test: /\\.(eot|svg|ttf|woff|woff2)(\\?\\S*)?$/, loader: &apos;file-loader&apos;}","link":"/2021/03/08/框架/解决vue引入ElementUI报错/"},{"title":"骨架屏","text":"骨架屏就是在页面内容未加载完成的时候，先使用一些图形进行占位，待内容加载完成之后再把它替换掉。 vue中引入骨架屏： 可引入的组件：https://github.com/egoist/vue-content-loader","link":"/2019/04/26/框架/骨架屏/"},{"title":"Jest","text":"","link":"/2021/03/04/测试框架/Jest/"},{"title":"使用Mocha进行自动化测试","text":"https://zh.javascript.info/testing-mocha 重要： https://www.liaoxuefeng.com/wiki/1022910821149312/1101741181366880 前端测试框架： https://juejin.cn/post/6844903800302469128","link":"/2021/01/30/测试框架/使用Mocha进行自动化测试/"},{"title":"浏览器中的EventLoop","text":"&lt;附&gt; 参考： http://www.ruanyifeng.com/blog/2014/10/event-loop.html https://wangdoc.com/javascript/events/model.html","link":"/2019/09/30/浏览器/浏览器中的EventLoop/"},{"title":"「chromium源码解读」浏览器事件机制","text":".red{color:red;} 从chrome源码侧webkit内核解读浏览器事件机制。原创解析转载请注明出处。 事件模型(Event Moudle) 事件订阅-发布相关源码（c++） 事件处理过程 DOM事件流 设置事件处理程序在事件流中的位置 观察者模式时序图 &lt;附&gt; 参考： 源码解析：https://zhuanlan.zhihu.com/p/25095179","link":"/2021/01/15/浏览器/浏览器事件机制/"},{"title":"浏览器缓存机制","text":"&lt;附&gt; 参考： http://bbs.qcloud.com/thread-3775-1-1.html https://www.jb51.net/article/51951.htm https://segmentfault.com/a/1190000016265991 https://juejin.im/entry/5ad86c16f265da505a77dca4","link":"/2019/09/30/浏览器/浏览器缓存机制/"},{"title":"浏览器跨域","text":"浏览器同源策略：协议、主机名、端口号不一致时，判定为不同源，即为跨域请求。 简单请求 复杂请求 解决方式 JSONP、CORS、postMessage","link":"/2021/09/26/浏览器/浏览器跨域/"},{"title":"UML类图与交互图","text":"总结UML类图与交互图相关知识，加深学习和理解。 .red{color:red;} https://www.jianshu.com/p/08015c0ca2f1","link":"/2019/08/09/程序设计/UML类图与交互图/"},{"title":"AST抽象树","text":"","link":"/2021/01/01/编译原理/AST抽象树/"},{"title":"Acorn解析","text":"","link":"/2021/01/01/编译原理/Acorn解析/"},{"title":"JavaScript柯里化","text":"Currying：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数。 123456789101112131415161718192021222324252627function add (x, y) { return (x + y)}console.log(add(1, 2))function curriedAdd (x) { return function (y) { return x + y }}console.log(curriedAdd(1)(3))console.log(curriedAdd(1)(3) === 4)function add (x, y) { return (x + y)}function currying (fn, ...args1) { return function (...args2) { return fn(...args1, ...args2) }}currying(add, 1)currying(add, 1)(2)","link":"/2021/01/12/编译原理/JavaScript柯里化/"},{"title":"JavaScript编译原理","text":"","link":"/2021/01/01/编译原理/JavaScript编译原理/"},{"title":"web安全","text":"出于安全考虑，外网请求接口频次受限，超过频次后会被WAF拦截。内网不受限制。 参考: https://baike.baidu.com/item/WAF","link":"/2019/10/10/网络安全/web安全/"},{"title":"前端脚手架","text":"工具封装，组件封装，网络请求库封装。","link":"/2021/01/01/脚手架/前端脚手架/"},{"title":"进程与线程","text":"巩固补充一波基础知识 进程是计算机中已运行程序的实体。进程是线程的容器，进程本身不运行。程序本身只是指令的集合，进程才是程序（指令）的真正运行。每个程序可以有多个进程，每个进程都有自己的资源。","link":"/2020/03/21/计算机基础/进程与线程/"},{"title":"HTTP响应代码","text":"简述前端常见HTTP响应代码对应网络状态。 100-199：信息性状态码，通常和url协议相关，表示接收的请求正在处理 200-299：成功状态码，用于表示请求正常处理完毕 300-399：重定向状态码，表示要么有缓存，要么做了重定向用于跳转 400-499：客户端错误状态码，表示服务器无法处理请求 500-599：服务器错误状态码，表示服务器处理请求出错 常见code码： 101 Switching Protocol: 该代码是响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。 200 OK: 请求成功。 301 Moved Permanently: 永久重定向，表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。 302 Found: 临时重定向，表示资源仍然可以访问，这个重定向只是临时地从旧地址 A 跳转到地址 B。 304 Not Modified: 协商缓存。 400 Bad Request: 请求参数有误。 403 Forbidden: 服务器已经理解请求，但是拒绝执行它。 404 Not Found: 请求失败。 500 Internal Server Error: 服务器遇到了不知道如何处理的情况。 Protocol https wss blob &lt;附&gt; 参考： https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status","link":"/2021/01/09/计算机网络/HTTP响应代码/"},{"title":"网络传输模型","text":"简述网络传输过程。 OSI(Open System Interconnection)七层参考模型 TCP/IP(Transmission Control Protocol/ Internet Protocol) KEY DIFFERENCE OSI has 7 layers whereas TCP/IP has 4 layers. The OSI Model is a logical and conceptual model that defines network communication used by systems open to interconnection and communication with other systems. On the other hand, TCP/IP helps you to determine how a specific computer should be connected to the internet and how you can be transmitted between them. OSI header is 5 bytes whereas TCP/IP header size is 20 bytes. OSI refers to Open Systems Interconnection whereas TCP/IP refers to Transmission Control Protocol. OSI follows a vertical approach whereas TCP/IP follows a horizontal approach. OSI model, the transport layer, is only connection-oriented whereas the TCP/IP model is both connection-oriented and connectionless. OSI model is developed by ISO (International Standard Organization), whereas TCP Model is developed by ARPANET (Advanced Research Project Agency Network). OSI model helps you to standardize router, switch, motherboard, and other hardware whereas TCP/IP helps you to establish a connection between different types of computers. &lt;附&gt; 参考： https://www.guru99.com/difference-tcp-ip-vs-osi-model.html#2","link":"/2020/12/22/计算机网络/网络传输模型/"},{"title":"传输协议","text":".pt{padding-top:10px;} 简述网络协议相关。 HTTPS传输比HTTP传输的优势？ HTTP协议以明文方式发送内容，不提供任何方式的数据加密。 HTTPS是在HTTP基础上加入了SSL协议(SSL协议是在OSI网络传输模型中的会话层中传输的安全协议)，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 使用不同的链接方式，端口也不同，一般而言，HTTP 协议的端口为 80，HTTPS 的端口为 443。 FTP的应用场景？ 迅雷BT种子、文件上传下载、身份验证、多点下载，断点续传等（部分场景被P2P和网盘替代） SMTP/POP3/IMAP的应用场景？ 电子邮件发送协议主要是SMTP，收件协议主要是POP3和IMAP Telnet和SSH的应用场景？ Telnet和SSH用于远程访问服务器的的两大常用协议。利用它们，我们可以管理并监控生产服务器和企业服务器，更新服务器内核，安装最新的软件包和补丁，能够远程登录服务器，开展软件开发、测试运行、更改代码和重新部署。 ws或wss(wss表示在TLS之上的Websocket)数据双向传输？ 允许服务端主动向客户端推送数据，数据大盘(数据间隔从服务端推送) 在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。数据双向传输的概念不仅仅是数据双向绑定这种理念，和协议通信相类似。","link":"/2020/01/13/计算机网络/计算机网络/"},{"title":"JSBridge原理及应用","text":"https://juejin.cn/post/6936814903021797389","link":"/2021/03/09/跨终端/JSBridge原理及应用/"},{"title":"electron跨终端实践","text":"","link":"/2021/03/07/跨终端/electron跨终端实践/"},{"title":"JavaScript设计模式-观察者模式","text":"概念：观察者模式也称发布者-订阅者模式（publisher-subscriber pattern)，用于让对象对事件进行监听以便对其作出响应。 观察者模式可谓无处不在，无论是自行构建，还是用框架中封装好的，都极其常见。深入的理解和学习显得尤为重要。当出现问题时，也可更快速准确的定位问题的根源。 为了更深刻的理解观察者模式，举个例子。在报纸行业中，发布和订阅的顺利进行，依赖于两个角色，报社和订阅者。报社在出版报纸后，将报纸投递至订阅者。订阅者可订阅多家报刊，报刊可投递给多个订阅者，则这是个多对多的关系。投递的方式可为两种：推和拉。订阅者可订阅和退订。报社可“送”也可“订阅者取”。 此例子来源《JavaScript设计模式》。注：网上普遍认为该模式为“一对多”的关系，此书解释为“多对多”的对应关系。我认为也更为恰当一些。 目前，前端实践上，主流框架AngularJs、Vue、React、BackBone等中均广泛应用。RxJS更是使用Observables的响应式编程的库.观察者模式能够松耦合，在模块化设计当中扮演着非常重要的角色。MVC、MVVM模式中最底层的就是观察者模式。 此处举个简单常用的例子，组件间的传值。 实现方式：为了便捷简明的说明此模式，此处举例为“一对一”的对应关系，同时借用jquery框架。用jquery实现类似vue、Angular的$emit(事件触发),$on(事件绑定)的设计。 12345678910111213141516171819202122// 发布者function Publisher() { var self = this; self.dispatcher = $({});}// 触发send操作时，发布信息Publisher.prototype.send = function (){ var self = this self.dispatcher.trigger(&quot;sendMessage&quot;, [&quot;Yes&quot;]);}// 订阅者var subscribe = new Publisher()// 订阅者获取信息subscribe.dispatcher.on(&apos;sendMessage&apos;,function(data){ console.log(data); // 输出“Yes”});// 发送信息触发subscribe.send(); 注： 部分观点认为观察者模式and发布者-订阅者模式是两种不同的模式。待考证 复杂业务场景“一对多”、“多对一”、“多对多”模式。待补充 #未完待续#","link":"/2019/05/24/设计模式/JavaScript设计模式-观察者模式/"},{"title":"设计模式概览","text":"总结设计模式的概念、结构、UML类图和交互图、适用性等理论知识，以便深入学习和理解。 .red{color:red;} 原则：找出程序中变化的地方，并将变化封装起来。 理解和应用上恐有偏差，会持续更新完善 创建型模式 Abstract Factory(抽象工厂)–对象创建型模型 概念：提供一个接口以创建一系列相关或相互依赖的对象，而无须指定它们具体的类。 Builder(生成器) 概念：将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。 Singleton(单例模式) 概念：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 理解点在于： 让类自身负责保存它的唯一实现（通过截取创建新对象的请求，让类可以保证没有其他实例可以被创建）。 并提供可以访问该实例的方法。 应用实践：登陆弹框 行为型模式 Mediator(中介者) 概念：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地互相引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 Observer(观察者) 概念：定义对象间的一种一对多的关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 副作用：需要维护相关对象的一致性。 Strategy(策略模式) 概念：定义一系列的算法，把他们一个个封装起来，并且使可相互替换。本模式使得算法可独立于使用它的客户而变化。 实例：https://github.com/sunhui-blog/designPatterns 代码后续会逐渐优化~ 格式 模式名称 概念：待补充 理解点在于：待补充 副作用：待补充 类图：待补充 交互图：待补充 应用实践：待补充 #未完待续#","link":"/2019/07/29/设计模式/设计模式概览/"},{"title":"适配器设计","text":"定义：将一个类的接口转换成客户希望的另外一个接口。别名：包装器（wrapper）。 .red{color:red;} .mb10{margin-bottom:10px;} 实现方式：类适配器和对象匹配器。示例：Java实现。 类适配器 12345678910111213141516171819202122232425262728interface Target { void Request();}class Adaptee { public void SpecificRequest() { System.out.println(&quot;三足插头--充电&quot;); }}class Adapter extends Adaptee implements Target { @Override public void Request() { super.SpecificRequest(); System.out.println(&quot;两足插头--充电&quot;); }}public class Client1 { public static void charge(Target target) { target.Request(); } public static void main(String[] args) { Adapter ad = new Adapter(); charge(ad); }} 对象匹配器 123456789101112131415161718192021222324252627282930313233interface Target { void Request();}class Adaptee { public void SpecificRequest() { System.out.println(&quot;三足插座-充电&quot;); }}class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void Request() { adaptee.SpecificRequest(); System.out.println(&quot;两足插头--充电&quot;); }}public class Client2 { public static void charge(Target target) { target.Request(); } public static void main(String[] args) { Adapter ad = new Adapter(new Adaptee()); charge(ad); }} 适用场景： 使用一个已经存在的类，而它的接口不符合你的需求。 创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类(即那些接口可能不一定兼容的类)协同工作。 (仅适用于对象Adapter)想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。","link":"/2021/11/02/设计模式/适配器设计/"},{"title":"Chrome源码导读","text":".pt{padding-top:10px;} 罗列一些Chrome源码解读相关的资料。mark归整一些点的理解。 https://www.cnblogs.com/yincheng/category/761296.html","link":"/2020/09/02/阅读源码/Chrome源码导读/"},{"title":"Node.js核心思想与源码分析","text":"","link":"/2021/01/01/阅读源码/Node-js核心思想与源码分析/"},{"title":"React 17源码本地调试环境搭建","text":".mt10 { margin-top: 10px; } .m10 { margin: 10px 0; } .pt10 { padding-top: 10px; } .red { color: red; } 为了更连贯了解React底层源码运行机制及原理，通过搭建源码层调试环境反复调试，加深对底层运行原理深入理解及作者对框架本身架构层的设计深化。 参考react源码调试环境搭建：https://zhuanlan.zhihu.com/p/336933386 搭建过程中遇到的问题处理： 修改webpack配置 修改config/webpack.config.js 1234567891011121314151617181920resolve: { alias: { &apos;react-native&apos;: &apos;react-native-web&apos;, &apos;react&apos;: path.resolve(__dirname, &apos;../src/react/packages/react&apos;), &apos;react-dom&apos;: path.resolve(__dirname, &apos;../src/react/packages/react-dom&apos;), &apos;shared&apos;: path.resolve(__dirname, &apos;../src/react/packages/shared&apos;), &apos;react-reconciler&apos;: path.resolve(__dirname, &apos;../src/react/packages/react-reconciler&apos;), // 补充 &apos;react-devtools-scheduling-profiler&apos;: path.resolve(__dirname, &apos;../src/react/packages/react-devtools-scheduling-profiler&apos;), &apos;react-devtools-shared&apos;: path.resolve(__dirname, &apos;../src/react/packages/react-devtools-shared&apos;), ...(isEnvProductionProfile &amp;&amp; { &apos;react-dom$&apos;: &apos;react-dom/profiling&apos;, &apos;scheduler/tracing&apos;: &apos;scheduler/tracing-profiling&apos;, }), ...(modules.webpackAliases || {}), }} 修改package.json的babel配置 12345678910&quot;babel&quot;: { &quot;presets&quot;: [ [ &quot;react-app&quot;, { &quot;runtime&quot;: &quot;automatic&quot; } ] ]} &lt;附&gt; 参考： react源码调试环境搭建：https://zhuanlan.zhihu.com/p/336933386 ReferenceError: React is not defined 报错解决方法：https://blog.csdn.net/qq_38605121/article/details/109390989","link":"/2021/09/30/阅读源码/React-17源码本地调试环境搭建/"},{"title":"babel源码","text":"","link":"/2021/01/01/阅读源码/babel源码/"},{"title":"koa源码","text":"koa源码。 入口文件地址：lib/application.js","link":"/2021/01/16/阅读源码/koa源码/"},{"title":"express源码","text":"express源码。","link":"/2021/01/05/阅读源码/express源码/"},{"title":"gulp源码","text":"","link":"/2021/01/11/阅读源码/gulp源码/"},{"title":"postcss源码","text":"","link":"/2021/01/11/阅读源码/postcss源码/"}],"tags":[{"name":"编程语言","slug":"编程语言","link":"/tags/编程语言/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/前后端分离/"},{"name":"书籍","slug":"书籍","link":"/tags/书籍/"},{"name":"架构","slug":"架构","link":"/tags/架构/"},{"name":"工具","slug":"工具","link":"/tags/工具/"},{"name":"异常&性能","slug":"异常-性能","link":"/tags/异常-性能/"},{"name":"持续集成","slug":"持续集成","link":"/tags/持续集成/"},{"name":"操作系统","slug":"操作系统","link":"/tags/操作系统/"},{"name":"数据可视化","slug":"数据可视化","link":"/tags/数据可视化/"},{"name":"数据库","slug":"数据库","link":"/tags/数据库/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"服务器","slug":"服务器","link":"/tags/服务器/"},{"name":"框架","slug":"框架","link":"/tags/框架/"},{"name":"测试框架","slug":"测试框架","link":"/tags/测试框架/"},{"name":"浏览器","slug":"浏览器","link":"/tags/浏览器/"},{"name":"程序设计","slug":"程序设计","link":"/tags/程序设计/"},{"name":"编译原理","slug":"编译原理","link":"/tags/编译原理/"},{"name":"脚手架","slug":"脚手架","link":"/tags/脚手架/"},{"name":"网络知识","slug":"网络知识","link":"/tags/网络知识/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"源码","slug":"源码","link":"/tags/源码/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"FQA","slug":"FQA","link":"/categories/FQA/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"书虫","slug":"书虫","link":"/categories/书虫/"},{"name":"架构","slug":"架构","link":"/categories/架构/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"工程化","slug":"工程化","link":"/categories/工程化/"},{"name":"异常&性能","slug":"异常-性能","link":"/categories/异常-性能/"},{"name":"总结","slug":"总结","link":"/categories/总结/"},{"name":"持续集成","slug":"持续集成","link":"/categories/持续集成/"},{"name":"操作系统","slug":"操作系统","link":"/categories/操作系统/"},{"name":"数据可视化","slug":"数据可视化","link":"/categories/数据可视化/"},{"name":"数据库","slug":"数据库","link":"/categories/数据库/"},{"name":"数据结构&算法","slug":"数据结构-算法","link":"/categories/数据结构-算法/"},{"name":"服务器","slug":"服务器","link":"/categories/服务器/"},{"name":"框架","slug":"框架","link":"/categories/框架/"},{"name":"测试框架","slug":"测试框架","link":"/categories/测试框架/"},{"name":"浏览器","slug":"浏览器","link":"/categories/浏览器/"},{"name":"程序设计","slug":"程序设计","link":"/categories/程序设计/"},{"name":"编译原理","slug":"编译原理","link":"/categories/编译原理/"},{"name":"网络安全","slug":"网络安全","link":"/categories/网络安全/"},{"name":"脚手架","slug":"脚手架","link":"/categories/脚手架/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/计算机基础/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/计算机网络/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"阅读源码","slug":"阅读源码","link":"/categories/阅读源码/"}]}